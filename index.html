<!DOCTYPE html>
<html>
  <head>
    <!-- leaflet -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
  
    <!-- deck.gl standalone bundle -->
    <script src="https://unpkg.com/deck.gl@9.1.5/dist.min.js"></script>
    <!-- deck.gl-leaflet -->
    
    <script src="https://unpkg.com/deck.gl-leaflet@1.3.1/dist/deck.gl-leaflet.umd.min.js"></script>

    <script src="./js/centerPointGeoJson.js"></script>
    <script src="./js/filtergeojson.js"></script>

    <style>
      #map {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>
  </body>
  <script>console.log("Leaflet loaded version:", L.version);</script>

  <script type="text/javascript">
    const defaultStyle = {
        fillColor: "#cbc9e2", 
        color: "#9e9ac8",       // Border color
        weight: 1,
        fillOpacity: 0.6
    };

    const hoverStyle = {
        fillColor: "#9e9ac8",
        color: "#9e9ac8",
        weight: 1,
        fillOpacity: 0.8
    };

    const selectedStyle = {
        fillColor: "#54278f", 
        weight: 1
    };

    // Initialize the map
    const map = L.map('map').setView([2.5, 20.0], 1);

    L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/light-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibXdpc2NnIiwiYSI6ImNtN2VtbGEzNzBnaTgyam9vZXl3YzM2Ym4ifQ.YJe4CFT-CEYhl0D98Wk8aw', {
    attribution: '© <a href="https://www.mapbox.com/about/maps/">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
    tileSize: 512,
    zoomOffset: -1,
    }).addTo(map);

    // Fetch and add GeoJSON data
    fetch("data/WorldPoly.geojson")
      .then(response => response.json())
      .then(data => {
          L.geoJson(data, {
            style: defaultStyle, // Set default style
            onEachFeature: onEachFeature // Attach event listeners 
          }).addTo(map);
      })
      .catch(error => console.error("Error loading GeoJSON:", error));

    // Event functions to apply and remove styles
    function onEachFeature(feature, layer) {
        layer.on({
            mouseover: function (e) {
                e.target.setStyle(hoverStyle); // Apply hover style
            },
            mouseout: function (e) {
                e.target.setStyle(defaultStyle); // Reset to default style
            },
            click: function (e) {
                e.target.setStyle(selectedStyle); // Apply selected style on click
            }
        });

        // Add a popup with country name
        if (feature.properties && feature.properties.ADMIN) {
            layer.bindPopup(`<b>Country:</b> ${feature.properties.ADMIN}`);
        }
    }

    // async function fetchWikidataGeoJSON() {
    //     const response = await fetch('./data/countryCenterPoints.geojson');
    //     return await response.json();
    // }

    function getCoordinatesByISO3(geojsonData, iso3) {
        for (let feature of geojsonData.features) {
            if (feature.properties.iso3166_3 === iso3) {
                return feature.geometry.coordinates;
            }
        }
        return null; // If no matching ISO3 code found
    }

    // Fetch and add country center points
    async function getCountryCenterPoints() {
        try {
            const geoJSON = await fetchWikidataGeoJSON(); // Fetch data from centerPointGeoJson.js
            return geoJSON;
        } catch (error) {
            console.error("Error loading country centerpoints:", error);
        }
    }

    async function countryCentroidsGeoJSON() {
        const centroid = await getCountryCenterPoints();
        return centroid;
    }

    countryCentroidsGeoJSON().then(countryCentroids => {
        console.log(countryCentroids);
        const filteredGeoJSON = filterGeoJSONByISO3(countryCentroids, ["CAN", "USA"]);
        console.log(filteredGeoJSON);

        const startingPoint = getCoordinatesByISO3(countryCentroids, "GBR");

        selectedCountries = ["AGO", "BDI", "BEN", "BFA", "BWA", "CAF", "CIV", "CMR", "COD", "COG", "COM", 
                            "CPV", "DJI", "DZA", "EGY", "ERI", "ETH", "GAB", "GHA", "GIN", "GMB", "GNB", 
                            "GNQ", "KEN", "LBR", "LBY", "LSO", "MAR", "MDG", "MLI", "MOZ", "MRT", "MUS", 
                            "MWI", "NAM", "NER", "NGA", "RWA", "SDN", "SEN", "SLE", "SOM", "SSD", "STP", 
                            "SWZ", "SYC", "TCD", "TGO", "TUN", "TZA", "UGA", "ZAF", "ZMB", "ZWE"];
        const deckLayer = new DeckGlLeaflet.LeafletLayer({
        views: [
            new deck.MapView({
            repeat: true
            })
        ],
        layers: [
            new deck.ArcLayer({
            id: 'arcs',
            data: countryCentroids,
            // dataTransform: d => d.features.filter(f => f.properties.iso3166_3 === "USA"),
            dataTransform: d => d.features.filter(f => selectedCountries.includes(f.properties.iso3166_3)),
            // Styles
            getSourcePosition: f => startingPoint, 
            getTargetPosition: f => f.geometry.coordinates,
            getSourceColor: [0, 128, 200],
            getTargetColor: [200, 0, 80],
            getWidth: 1
            })
        ],
        });
        map.addLayer(deckLayer);
        // const startingPoint = getCoordinatesByISO3(countryCentroids, "GBR");

        // const countryList = ["FRA", "USA"];
        // const endingPoints = [];

        // // Loop over each country ISO3 code and push its coordinates into endingPoints
        // countryList.forEach(countryCode => {
        //     const coordinates = getCoordinatesByISO3(countryCentroids, countryCode);
        //     if (coordinates) {
        //         endingPoints.push(coordinates);
        //     }
        // });

        // console.log("Starting Point:", startingPoint);
        // console.log("Ending Points:", endingPoints);

        // // Prepare ArcLayer data
        // const arcData = endingPoints.map(endPoint => ({
        //     sourcePosition: startingPoint,
        //     targetPosition: endPoint
        // }));

        // // Create the ArcLayer
        // const arcLayer = new deck.ArcLayer({
        //     id: 'arc-layer',
        //     data: arcData,
        //     getSourcePosition: d => d.sourcePosition,
        //     getTargetPosition: d => d.targetPosition,
        //     getWidth: 2,
        //     getSourceColor: [255, 140, 0], // Orange color
        //     getTargetColor: [0, 255, 255], // Cyan color
        // });

        // // Integrate with Leaflet
        // const deckOverlay = new deck.DeckGL({
        //     layers: [arcLayer],
        //     initialViewState: {
        //         longitude: startingPoint[0],
        //         latitude: startingPoint[1],
        //         zoom: 3,
        //         pitch: 30
        //     },
        //     getTooltip: ({ object }) =>
        //         object && `From: GBR\nTo: ${object.targetPosition}`,
        // });

        // L.deckGL(deckOverlay).addTo(map);
    });
  </script>
</html>